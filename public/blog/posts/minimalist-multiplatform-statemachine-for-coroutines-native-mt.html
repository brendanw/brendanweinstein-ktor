<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Posts - Brendan Weinstein</title>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
  <style>
    @font-face {
      font-family: 'd-condensed'; /*a name to be used later*/
      src: url('https://d3gbt3n5waomy7.cloudfront.net/style/font/d-condensed.otf'); /*URL to font*/
    }

    body {
      margin: 0;
      padding: 0;
    }

    header {
      margin: 0 0 0 0;
      padding: 0 0 0 0;
      width: 100%;
      height: 150px;
      background: #000;
      color: #FFF;
      display: flex;
      align-items: center;
    }

    header h1 {
      margin: 0 0 0 0;
      padding: 0 0 0 0;
      font-size: 50px;
      letter-spacing: 15px;
      font-family: d-condensed, sans-serif;
      color: #FFF
    }

    header h1 a {
      text-transform: uppercase;
      margin-left: 50px;
      user-select: none;
      color: inherit;
      text-decoration: none;
    }

    header h1 a:hover {
      text-transform: uppercase;
      margin-left: 50px;
      user-select: none;
      color: inherit;
      text-decoration: none;
    }

    .blog-item-list {
      margin-top: 50px;
    }

    .blog-item {
      font-family: monospace;
    }

    .main-content {
      margin-left: 50px;
      margin-top: 50px;
      margin-right: 50px;
      max-width: 900px;
    }

    h2 {
      margin-bottom: 30px;
    }
  </style>
</head>
<body>
<header>
  <h1>
    <a href="/blog">Brendan Weinstein</a>
  </h1>
</header>
<div class="main-content">
  <h2>Minimalist Multiplatform State Machine for Coroutines Native-MT</h2>

  <p class="date"><i>28 March 2020</i></p>

  <p>I've had an aversion to design pattern-itis having witnessed teams spend far too many hours debating pros and cons
  of pattern A vs pattern B, only to lose more hours when folks struggle to read new code that diverges from the old
  pattern. Sometimes it's better to just stick with what is boring, old, and predictable and focus on shipping.</p>

  <p>BaseBeta is a small business I help run with a small team. We have a mobile-friendly website, native android app,
  and native iOS app. Since we are a small team, we designed the android and iOS apps to be near replicas. We used MVP
  paired with Rx as the design pattern on both platforms. It feels pretty fluent to write a simple feature on one
    platform and manually transpile it to the other.</p>

  <p>It's so fluent that it gives you the code smell that this should be automated.</p>

  <p>We've kept native apps for android and iOS because having reliable offline store of media was core to our product.
  We also wanted to have performant charts and graphs for users' gps tracks. In the long-run we'd like to add features
  that pair with bluetooth devices. These all tilt things in favor of native apps.</p>

  <p>Kotlin multiplatform caught my attention as it offered the ability to implements features that take advantage
  of native-only capabilities but make sure the nuts and bolts only have to be written once. It seemed clear that MVP would
  not be the best pattern to use for minimizing duplicate logic on android and iOS. A pattern I had first heard about on
  Fragmented stood out: MVI</p>

  <p>MVI allows you to define a state machine that takes strongly typed inputs and spits out immutable ViewState's.
  You can define your StateMachine using pure kotlin code with no references to native android or iOS frameworks, and
  then easily plug that StateMachine into your UI. The best examples for this pattern came from Kaushik Gopal's blog,
  RxRedux, and CoRedux. While there is RxJava support for kotlin multiplatform, it felt unidiomatic to go down that path
  when coroutines is aiming to have similar offerings. I tried to copy CoRedux and update some of the jvm-specific classes
  to use kotlin alternatives but ran into some difficult to parse InvalidMutabilityException's. The library was written
    without making use of Flow and was a bit difficult for me to step through without concerted effort.</p>

  <p>I eventually resolved to write my own MVI implementation specific for multiplatform so that way I'd have the best
  context for understanding any kotlin-native issues that might crop up. I am pretty happy with what I arrived at, but it
  did take me a bit longer than I'd have liked:</p>

  <pre>
class StateWrapper<T>(var state: T)

class StateMachine<R : Any, T>(
  val scope: CoroutineScope,
  private val initialState: T,
  private val sideEffects: List<(Flow<R>, () -> T) -> Flow<R>>,
  private val reducer: suspend (accumulator: T, value: R) -> T
) {
  val viewState: FlowRelay<T> = FlowRelay()
  private var isInitialized = atomic(false)
  private val inputActions: BroadcastChannel<R> = BroadcastChannel(Channel.BUFFERED)

  init {
    scope.launch {
      val lastState = StateWrapper(initialState)
      val flowList = sideEffects.map { sideEffect ->
        sideEffect(inputActions.asFlow(), { lastState.state })
      }.run {
        toMutableList().apply {
          add(inputActions.asFlow())
        }
      }
      flowList.onBindMerge {
          isInitialized.value = true
        }
        .onEach { kprint("result $it") }
        .onCompletion {
          kprint("cancelling initial inputFlow")
          inputActions.cancel()
        }
        .scan(lastState.state, reducer)
        .distinctUntilChanged()
        .collect { outputState ->
          lastState.state = outputState
          viewState.send(outputState)
        }
    }

    fun dispatchAction(action: R) = scope.launch {
      kprint("Received input action $action")
      while (!isInitialized.value) {
        yield()
      }
      inputActions.send(action)
    }
  }

}
  </pre>

</div>
</body>
</html>
